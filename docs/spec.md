承知いたしました。DACL v0.9 の最終的な仕様書をMarkdown形式でまとめます。この内容を `docs/spec/dacl-v0.9-spec.md` にコピーしてご活用ください。

---

# DACL: Data And Configuration Language - 仕様書 v0.9

## 概要

DACL (Data And Configuration Language) は、シンプルさと堅牢性を追求した、人間にとっても機械にとっても読みやすい設定ファイルフォーマットです。YAMLの簡潔さと表現力を参考にしつつ、曖昧さを排除し、エラーの発生しにくい構造を目指して設計されました。

## 1. 基本設計思想

* **シンプルさと堅牢性**: 必要最低限の機能で、曖昧さを排除し、エラーの発生しにくい構造を目指す。
* **視覚的明瞭性**: 2スペースのインデントにより構造が明確に把握できることを重視する。
* **機械可読性**: パースが容易であること。
* **人間可読性**: 記述が直感的で理解しやすいこと。
* **モジュール性**: 外部ファイル参照による設定の分割と再利用を可能にする。

## 2. データ構造

以下の基本的なデータ構造をサポートする。

* **マップ (Map / Dictionary / Object)**: キーと値のペアの集まり。順序は保証しない。
* **リスト (List / Array)**: 順序付けられた値の集まり。
* **スカラー値 (Scalar)**: 単一の値。

## 3. 構文ルール

### 3.1. インデント

* **スペースのみ**: インデントには半角スペースのみを使用し、タブは使用禁止とする。
* **固定インデント幅**: 各レベルのインデントは、常に2スペースを使用する。
* **厳密なインデント**: インデントレベルが不適切である場合、パースエラーとする。

### 3.2. マップ (キー-バリューペア)

* `キー: 値` の形式で記述する。
* キーとコロンの間にはスペースを入れない。
* コロンと値の間には少なくとも1つのスペースを入れる。
* **キー名の制約**:
    * アルファベット小文字 (`a-z`)、アルファベット大文字 (`A-Z`)、数字 (`0-9`)、アンダースコア (`_`) を許可する。
    * 数字から始まるキー名も許可する。
    * キー名にドット (`.`) は使用できない（パス区切り文字と混同を避けるため）。
    * 重複キーは、同一マップ内では禁止とする。パースエラーとする。
* 例:
    ```dacl
    server:
      port: 8080
      debug_mode: true
    1st_service:
      name: "primary-app"
    ```

### 3.3. リスト (配列)

* 各リスト要素は、`-` (ハイフン) で始まり、その後に少なくとも1つのスペースを置く。
* `-` は親のマップまたはリストのインデントレベルから、さらに2スペース深くインデントされる。
* リスト要素がスカラー値の場合、`- 値` の形式で記述する。
* リスト要素がマップや別のリストの場合、その要素は `-` に続く形で新しいインデントレベルで記述される。
* **厳密なリストのインデント**: リストの各要素 (`-`) は、同じインデントレベルで揃っている必要がある。揃っていない場合はエラーとする。
* 例:
    ```dacl
    fruits:
      - "apple"
      - "banana"
      - "cherry"
    users:
      - name: "Alice"
        id: 101
      - name: "Bob"
        id: 102
    nested_list:
      -
        - "item1_1"
        - "item1_2"
      -
        - "item2_1"
        - "item2_2"
    ```

### 3.4. スカラー値

以下のデータ型を厳密に区別して扱う。

* **文字列 (String)**:
    * 常に**ダブルクォーテーション (`"`) で囲むことを必須**とする。
    * エスケープシーケンス (`\n`, `\t`, `\"`, `\\` など) をサポートする。
    * 例: `name: "My Service"`
* **整数 (Integer)**:
    * 符号付きの整数 (`0`, `123`, `-45`)。
    * アンダースコア (`_`) はセパレータとして使用可能（例: `1_000_000`）。
    * 例: `port: 8080`
* **浮動小数点数 (Float)**:
    * 小数点を含む数値 (`3.14`, `-0.5`)。
    * 指数表記 (`1.2e-3`) をサポート。
    * 例: `temperature: 25.5`
* **真偽値 (Boolean)**:
    * `true` または `false` のみ（厳密に小文字）。
    * 例: `enabled: true`
* **Null値**:
    * `null` のみ（厳密に小文字）。
    * 例: `optional_setting: null`

### 3.5. コメント

* 行コメントのみをサポートする。
* `#` (シャープ) で始まり、行末までがコメントとなる。
* 例:
    ```dacl
    # これはコメントです
    server:
      port: 8080 # ポート番号
    ```

## 4. 設定値の参照

設定ファイル内の特定のデータ構造や値を、その階層位置を示すパスで参照できるようにする。また、環境変数も参照可能とする。

### 4.1. パス参照の構文

* 参照したい場所に `${パス}` の形式で記述する。
    * これは文字列の一部に埋め込むことも可能（例: `"log_file: /var/log/${app.name}.log"`）。
    * 単独で値として参照する場合は、`key: ${path.to.value}` のようになる。
* パスは、ルートからの絶対パスで指定する。
* ドット (`.`) を区切り文字として使用し、各キー名またはリストのインデックスを続ける。
* リストの要素を参照する場合: `list_name.インデックス` のように0から始まる数値インデックスを使用する。（例: `users.0.name`）
* 存在しないパスを参照した場合、パースエラーとする。
* 循環参照の禁止: 例えば、`a: ${b}` と `b: ${a}` のように相互に参照しあうことはエラーとする。
* 参照は、スカラー値だけでなく、マップやリスト全体を指すことも可能とする。

### 4.2. 環境変数の参照

* 環境変数は、`${env:環境変数名}` の形式で参照する。
    * 例: `api_key: ${env:MY_API_KEY}`
    * 例: `database_url: "jdbc:postgresql://${env:DB_HOST}:${env:DB_PORT}/${env:DB_NAME}"`
* 環境変数名には、通常の環境変数命名規則（アルファベット、数字、アンダースコア）に従う文字列を使用する。
* **デフォルト値の指定 (オプション)**: 環境変数が設定されていない場合に備え、デフォルト値を指定できる。
    * 構文: `${env:環境変数名:-デフォルト値}`
    * 例: `debug_level: ${env:DEBUG_LEVEL:-info}`
    * `:-` の後ろのデフォルト値には、文字列、数値、真偽値、nullなど、そのフィールドに期待されるスカラー値を直接記述できる。
    * デフォルト値として、設定ファイル内の他のパスを参照することは許可しない（シンプルな運用を維持するため）。
* **必須の環境変数**: デフォルト値が指定されていない環境変数が存在しない場合、パースエラーとする。デフォルト値が指定されている場合は、環境変数が存在しなくてもエラーとしない。
* 環境変数参照は、その値がスカラー値として扱われることを想定する。マップやリスト全体を環境変数で表現することはサポートしない。

### 4.3. 参照のセマンティクス

* 参照された値は、参照元の値の**ディープコピー**として扱われる。（参照先の値が変更されても、参照元や他の参照先に影響を与えない）。

### 4.4. 参照の評価順序

設定ファイルがパースされる際、パス参照と環境変数参照は以下のように評価されるものとする。

1.  **環境変数参照の評価**: まず、すべての `${env:...}` 参照を評価し、対応する環境変数の値で置き換える。環境変数が存在しない、またはデフォルト値が指定されていない場合はエラーとする。
2.  **内部パス参照の評価**: その後、すべての `${パス}` 参照を評価し、設定ファイル内の他の値で置き換える。循環参照がある場合はエラーとする。

### 4.5. 変数定義専用セクションの推奨

* 一般的な設定値として再利用したいスカラー値やシンプルな構造は、ルートレベルに**`_var:`**のような専用のセクションを設けて定義することを推奨する。これにより、設定ファイル全体の構造が分かりやすくなる。`_var:` セクションは必須ではなく、記述者の判断に委ねられる。

## 5. 外部ファイル参照 (External File Inclusion with Namespaces)

設定ファイル内で、別の設定ファイルを指定した名前空間の下に読み込み、その名前空間からドット区切りで内容を参照できるようにする。

### 5.1. 構文

* `import "ファイルパス" as "名前空間名"` の形式で記述する。
* `import` キーは、現在のファイルパスからの相対パス、または絶対パスを受け入れる。
* ファイルパスは、ダブルクォーテーション (`"`) で囲まれた文字列とする。
* 名前空間名は、**キー名の制約（アルファベット、数字、アンダースコア。数字始まりも許可。ドットは使用不可）**に従うものとする。名前空間名もダブルクォーテーションで囲む。
* `import` キーは、マップのキーとしてのみ使用できる。リストの要素として直接インクルードしたり、スカラー値の中に埋め込んだりすることはできない。
* 同じレベルで、`import` キーと他のキーを混在させることも可能とする。
* `import` の行自体には、インデントは不要（ルートレベルでのみ使用可能と解釈）。

### 5.2. 参照ルール

* インポートされたファイルの内容は、指定された名前空間名のキーの下に配置されたものとして扱われる。
* 例えば、`import "db.dacl" as "prod_db"` と記述した場合、`db.dacl` の中の `host` というキーは、`prod_db.host` として参照可能になる。
* 名前空間名の衝突: 既存のキーや他の `import` で指定された名前空間名と衝突した場合、エラーとする。これにより、予期せぬ上書きを防ぎ、参照の明確性を保つ。

### 5.3. 処理順序

* ファイルがパースされる際、`import` ディレクティブが見つかると、その時点で指定されたファイルを読み込み、再帰的にパースする。
* 循環参照（例: `a.dacl` が `b.dacl` をインポートし、`b.dacl` が `a.dacl` をインポート）はエラーとする。

### 5.4. 例

```dacl
# db.dacl (インポートされる側のファイル)
type: "postgres"
host: "db.production.example.com"
port: 5432
user: "admin"
password_file: "/etc/db_password"

# app.dacl (インポートする側のファイル)
import "db.dacl" as "prod_db" # db.daclの内容がprod_db名前空間に読み込まれる

service:
  name: "my-application"
  port: 8080

database_connection:
  type: ${prod_db.type} # prod_db名前空間の下のtypeを参照
  host: ${prod_db.host} # prod_db名前空間の下のhostを参照
  port: ${prod_db.port}
  user: ${prod_db.user}
  password_path: ${prod_db.password_file}

metrics:
  enabled: true
  interval_seconds: 60
```

## 6. その他

* **複数ドキュメントの禁止**: 1つのファイルには1つの設定ドキュメントのみを記述できる。
* **ファイルのエンコーディング**: UTF-8を必須とする。
* **ルート要素**: 設定ファイルは、単一のマップまたは単一のリストのいずれかをルート要素として開始する。
* **空ファイル**: 空のファイルは、空のマップ `{}` として解釈されるか、エラーとするか。これは実装上の詳細だが、一般的には空のマップが望ましい。

---